### 所有权

```rust
fn main() {
    // 创建一个 String 类型的值，并将其赋值给变量 s
    let s = String::from("hello");

    // 将变量 s 的所有权转移给变量 s2
    let s2 = s;

    // 这里编译器会报错，因为 s 的所有权已经转移给了 s2
    // println!("{}", s);

    // 可以使用 clone() 方法来克隆具有堆分配数据的值，创建一个新的值和一个新的所有者
    let s3 = s2.clone();

    println!("s2 = {}, s3 = {}", s2, s3);
}
```

在这个例子中，我们创建了一个 String 类型的值，并将其赋值给变量` s`。然后，我们将变量`s`的所有权转移给变量`s2`。由于 Rust 的所有权规则，`s`不再拥有其值的所有权，因此我们不能在后面的代码中使用它。然后，我们使用`clone()`方法来克隆` s2`，创建一个新的值和一个新的所有者。

### 不可变引用

```rust
fn main() {
    let s = String::from("hello");

    // 创建一个不可变引用
    let r1 = &s;
    let r2 = &s;

    println!("{} and {}", r1, r2);

    // 不能同时存在可变引用和不可变引用
    // let r3 = &mut s;
}
```

在这个例子中，我们创建了一个 String 类型的值，并将其赋值给变量`s`。然后，我们创建了两个不可变引用`r1`和`r2`，它们都借用了`s`的所有权。由于不可变引用不会修改值，因此可以同时存在多个不可变引用。

### 可变引用

```rust
fn main() {
    let mut s = String::from("hello");

    // 创建一个可变引用
    let r1 = &mut s;

    // 只能存在一个可变引用
    // let r2 = &mut s;

    r1.push_str(", world!");

    println!("{}", r1);
}
```

在这个例子中，我们创建了一个可变的 String 类型的值，并将其赋值给变量`s`。然后，我们创建了一个可变引用`r1`，它借用了`s`的所有权，并允许修改该值。由于可变引用是唯一的，因此我们不能创建另一个可变引用`r2`。最后，我们使用`push_str()`方法来修改`s`的值，并打印可变引用`r1`。